# SOLID
[wikipedia](https://en.wikipedia.org/wiki/SOLID)

## Definition
SOLID란 로버트 마틴이 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 첫글자만 모아서 만든 단어이다.

5가지 기본 원칙은 다음과 같다
* Single Responsibility Principle
* Open/Closed Principle
* Liskov Substitution Principle
* Interface Segregation Principle
* Dependency Inversion Principle

### Single Responsibility Principle
단일 책임 원칙으로 번역되며, 모든 클래스는 하나의 책임만 가지며 클래스는 그 책임을 완전히 캡슐화해야 함을 의미한다.

이에 대해 내가 이해한 내용은 다음과 같다.  
* 시계라는 클래스는 시계에 대한 책임만 지며, 시계줄에 대한 책임은 질 필요가 없다.  
* 시계에 문제가 생기면 시계 클래스 안에서 해결해야 하고, 그 문제를 밖에서 해결하면 안된다. 
* 시계 클래스에 시간 표시 외의 다른 기능을 추가한다면 해당 원칙에 위배된다.([이 부분 출처](https://victorydntmd.tistory.com/291))
-> 그러면 제 3의 기능이 들어간 시계를 만들고 싶을땐 시계 클래스에다가 넣지 말고 알람 시계라는 클래스를 만들어야 할까?
시계는 인터페이스로?

### Open/Closed Principle
개방/폐쇄 원칙이며, 개체는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다는 의미이다.

위키에서는 다음과 같이 설명하고 있다.
> 기능을 추가하거나 변경해야 할 때, 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.

이미 잘 구현된 기능에 기능을 추가적으로 덧붙이는 것은 언제나 열려있고, 그 기능을 직접 고치는것은 지양해야 한다고 이해했다.

세상에 있는 모든 라이브러리들이 100% 완벽하지는 않기에 라이브러리를 직접 수정해야 해결되는 경우도 있겠지만, 내 수준에서 그런 케이스는 없다고 봐도 무방하다.

개인적으로 생각하는 이 원칙의 결론은 모듈을 수정할 일을 최대한 줄이기 위해 모듈의 기능을 제대로 구현해야 한다고 본다.

### Liskov Substitution Principle
번역하면 리스코프 치환 원칙이다.  
자식 클래스는 자신의 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다는 의미이다.([출처](https://velog.io/@kyle/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-SOLID-%EC%9B%90%EC%B9%99-%EC%9D%B4%EB%9E%80))

대표적인 예시로 직사각형-정사각형 문제가 있다.
직사각형의 특징에 가로세로가 같다는 특징이 더해지면 정사각형이 된다.
직사각형 안에는 정사각형이 있지만 그 반대는 성립하지 않는 관계이다.

만약 직사각형을 상속하여 정사각형을 만들었다고 가정하면  
```java
Rectangle r = new Square();
```
위의 코드로 정의했을 때 오류는 안나지만, Rectangle은 Square의 가로세로가 같다는 특징을 사용하지 못한다.  
직접 [예시](https://steady-coding.tistory.com/383)의 코드를 실행해본 결과 Rectangle의 가로세로를 다르게 설정했지만, 출력결과 같은 값이 나왔다.
```java
Rectangle r = new Square();
r.setHeight(5);
r.setWidth(2);
System.out.println(r.getHeight()); // 2
```

이해하자면, 상속 받는 객체는 부모의 모든 것을 상속하지 않거나 부모에 없는 기능이 추가될거면 다른 클래스로 만드는게 낫다?
비슷한 특성이 있다고 모두 같은 카테고리에 속하는 것은 아니다?

### Interface Segregation Principle
인터페이스 분리 원칙이며, 위키피디아의 나온 표현에 따르면 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스보다 낫다는 의미이다.

여러 메소드가 담긴 인터페이스 하나보다 인터페이스 하나 당 한 기능이 있고 특정 메소드가 필요할때마다 인터페이스를 가져와서 구현하는 것이 낫다고 이해된다.  

간단하게 말하면, 한꺼번에 다 가져오지 말고 쓸것만 가져와서 쓰자.

### Dependency Inversion Principle
의존관계 역전 원칙이다.
이 원칙에 따르면, 상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 반전시켜 상위 계층이 하위 계층으로부터 독립되게 할 수 있다.
쉽게 설명하면 추상은 구체에 의존하지 않아야 하며, 구체는 추상의 의존해야 한다.([출처](https://blog.siner.io/2020/06/18/solid-principles/))

예를 들어, 상위 클래스인 과일이 하위 클래스인 사과에 의존이 된다면
과일 클래스는 사과클래스의 크기, 색깔에 영향을 받을 수 있다.
모든 과일은 빨간색이 아닌데 빨갛게 될 수도 있다는 의미이다.

그래서 해당 원칙을 적용하면 먼저 과일 클래스에 크기와 색깔을 추상적으로 설정한다.  
그리고 사과 클래스는 과일 클래스를 구현하여 사과에 맞는 크기와 색깔을 지정한다.

## 여담
완전히 이론적인 내용을 공부해본것 같다.  
이유는 잘 모르겠지만 객체지향에 대해 이해하는 과정이 그냥 재밌게 느껴진다.
