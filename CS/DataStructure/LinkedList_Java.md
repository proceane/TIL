# LinkedList 자바로 구현
[출처](https://opentutorials.org/module/1335/8857)  

자바는 컬렉션이라는 데이터 스트럭쳐를 제공  
컬렉션 안에 리스트가 있음  

ArrayList와 LinkedList는 구현방법이 다름  
ArrayList는 내부적으로 배열을 사용  
LinkedList는 객체를 만들고 객체와 객체를 연결함으로써 구현함  

### 노드 구현  
LinkedList에서 가장 중요한 것은 노드의 구현  

head는 첫번째 노드를 지정하는 참조값  
tail은 마지막 노드  
size는 노드의 크기. 노드를 변경할때마다 이 값들을 수정해야 함  
tail이나 size는 마지막 노드를 찾거나 노드의 수를 셀 때 연산의 횟수를 획기적으로 줄여줌  

객체 Node는 내부적으로 data와 next 변수를 가지고 있음  
data는 노드의 값, next는 다음 노드를 가리키는 참조값  

### 내부 구조  
Node라는 이름의 객체  
각 노드가 data field와 link field를 가지고 있음  
link field는 그냥 변수  
다음 리스트가 누구인지에 대한 레퍼런스 값을 저장하고 있는 것일뿐  

### 데이터 추가
### 시작에 추가
노드를 생성하고 새로운 노드의 다음 노드로 헤드를 지정, 헤드로 새로운 노드를 지정함  

<b>의문점</b>  
왜 새로운 노드의 next가 헤드값인가?  
왜 헤드값이 새로운 노드값이 되는가?  
- next가 다음 값인데 코드 상으로는 이전에 등록한 노드값같음  
- 값을 삽입하면 뒤로 밀리는 것인가?  
- 뒤로 밀린다고 간주하면 이해는 되지만 왜 뒤로 밀리는지는 모름  
-> 이게 시작에 추가하는거라서 뒤로 밀리는거  
정리하면 앞에서부터 들어오니까 헤드값이 바뀜

### 끝에 추가
리스트에 끝에 데이터를 추가할 때는 tail을 사용함  
tail이 없다면 마지막 노드를 찾아야 함  
마지막 노드를 찾는 작업은 첫 노드부터 마지막 노드까지 순차적으로 탐색을 해야하기때문에 최악의 상황이라고 할 수 있음  

시작에 추가가 추가값이 앞에서부터 들어오기때문에 헤드값이 변경되었음  
끝에 추가는 뒤로 들어오기때문에 테일값이 변경됨  

tail의 next는 생성된 node  
끝에 삽입하니까 tail도 node  

반대로 시작에 추가할때는 
node의 next는 기존에 맨앞에 있던 head값이 뒤로 밀리기때문에 newNode의 head는 기존의 head값이 됨  
그리고 새로운 head는 지금 추가되는 노드값이 됨  

### 중간에 추가
k번째에 추가한다고 할 때  
k-1번째 노드의 다음 노드에 추가하고 기존에 k위치에 있던 노드는 새로운 노드의 Next가 됨  

<b>의문점</b>  
그러면 k-1과 k번째 노드 값만 변경하면 되는건가?  
다른 노드값은 안건드리는 이유?  
1-2-3-4가 있고 1과 2 사이에 값을 추가한다고 할때  
1의 next는 2, 2의 next는 3, 3의 next는 4가 될 것  

1과 2사이에 1.5를 넣고싶을 때  
1의 next는 1.5, 1.5의 next는 2가 됨  
2의 next는 그대로 3, 그 외에도 다 그대로  

체인 하나를 추가로 연결할때 체인 중간에 풀어서 새로운 체인 넣고 앞뒤로 다시 잠가주면 되는 느낌?  

그래서 넣고자하는 인덱스와 인덱스-1에 위치한 노드만 건드리는듯  

### 삭제
### 처음 노드 삭제
첫번째 노드를 temp로 지정하고 head의 값을 두번째 노드로 변경함  
삭제한 노드를 리턴  

처음 노드를 삭제했기때문에 head는 삭제된 노드의 next노드로 바뀜  

### 중간의 데이터를 삭제
1. k-1번째 노드를 temp 노드로 지정  
2. k번째 노드를 삭제할 노드 변수에 기록  
3. k-1번째 노드의 next로 k번째 노드의 next노드로 지정  
4. 리턴할 변수에 삭제할 노드의 데이터 저장  
5. k번째 노드를 삭제  
6. 사이즈 1 차감  

<b>의문점</b>  
왜 null로 변환하면 삭제처리한것처럼 되는가?  

중간 데이터 삭제 로직은 먼저 k-1번째 노드의 다음 노드로 k번째 노드의 다음 노드로 교체를 하고 진행함  
k-1 -> k -> k+1 이렇게 연결이 되어있다면  
k-1 -> k+1로 바꾼다는 이야기  

그리고 그렇게 빠진 k번째 노드를 그냥 null로 해버리는듯  
값 자체는 리턴용으로 빼놓았으니 Node 객체는 null로 처리해놓고 안써버리면 그만인건가..  

LinkedList 클래스 내에서 k번째 값을 쓸 일이 없어지니까 아예 없애버리는 느낌..?  

### 탐색(indexOf)
값이 있다면 그 값이 발견되는 첫번째 인덱스 값을 리턴, 없으면 -1을 리턴  

head부터 시작해서 탐색 값과 탐색 대상의 값이 일치할때까지 비교  

next의 값이 null이라는 것은 더이상 탐색 대상이 없다는 것을 의미  
그래서 -1리턴  

탐색 대상을 찾았으면 대상의 인덱스 값을 반환  

### 여담  
구현해보면서 Queue 생각이 많이 났는데 생각해보니 Queue 선언할때 LinkedList를 사용한다는 것이 떠올랐음  

이 내용을 정리한 이유는 자료구조 공부하는데 예제가 c언어여서..  

링크드 리스트에서 중요한거는 노드와 노드끼리 잘 연결하는것?  